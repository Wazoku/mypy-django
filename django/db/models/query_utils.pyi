# Stubs for django.db.models.query_utils (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any
from django.utils import tree
from collections import namedtuple

PathInfo = namedtuple('PathInfo', 'from_opts to_opts target_fields join_field m2m direct')

class InvalidQuery(Exception): ...

class QueryWrapper:
    contains_aggregate = ... # type: Any
    data = ... # type: Any
    def __init__(self, sql, params): ...
    def as_sql(self, compiler=None, connection=None): ...

class Q(tree.Node):
    AND = ... # type: Any
    OR = ... # type: Any
    default = ... # type: Any
    def __init__(self, *args, **kwargs): ...
    def __or__(self, other): ...
    def __and__(self, other): ...
    def __invert__(self): ...
    def clone(self): ...
    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False): ...
    def refs_aggregate(self, existing_aggregates): ...

class DeferredAttribute:
    field_name = ... # type: Any
    def __init__(self, field_name, model): ...
    def __get__(self, instance, owner): ...
    def __set__(self, instance, value): ...

class RegisterLookupMixin:
    def get_lookup(self, lookup_name): ...
    def get_transform(self, lookup_name): ...
    @classmethod
    def register_lookup(cls, lookup, lookup_name=None): ...

def select_related_descend(field, restricted, requested, load_fields, reverse=False): ...
def deferred_class_factory(model, attrs): ...
def refs_aggregate(lookup_parts, aggregates): ...
def refs_expression(lookup_parts, annotations): ...
def check_rel_lookup_compatibility(model, target_opts, field): ...
